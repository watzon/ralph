require "file_utils"

module Ralph
  module Cli
    module Generators
      class ModelGenerator
        @name : String
        @fields : Array(String)
        @table_name : String
        @class_name : String
        @models_dir : String
        @migrations_dir : String

        def initialize(
          name : String,
          fields : Array(String),
          @models_dir : String = "./src/models",
          @migrations_dir : String = "./db/migrations",
        )
          @name = name
          @fields = fields
          @class_name = name.camelcase
          @table_name = name.underscore + "s"
        end

        def run
          create_model_file
          create_migration_file
          puts "Created model: #{@class_name}"
          puts "  - #{@models_dir}/#{@name.underscore}.cr"
          puts "  - #{@migrations_dir}/XXXX_create_#{@table_name}.sql"
        end

        private def create_model_file
          FileUtils.mkdir_p(@models_dir)

          model_file = File.join(@models_dir, "#{@name.underscore}.cr")

          if File.exists?(model_file)
            puts "Model file already exists: #{model_file}"
            return
          end

          content = generate_model_content

          File.write(model_file, content)
        end

        private def create_migration_file
          FileUtils.mkdir_p(@migrations_dir)

          timestamp = Time.utc.to_s("%Y%m%d%H%M%S")
          migration_file = File.join(@migrations_dir, "#{timestamp}_create_#{@table_name}.sql")

          content = generate_migration_content

          File.write(migration_file, content)
        end

        private def generate_model_content : String
          field_definitions = @fields.map do |field|
            parse_field(field)
          end.join("\n  ")

          <<-MODEL
# #{@class_name} model
#
# Generated by Ralph ORM

class #{@class_name} < Ralph::Model
  table "#{@table_name}"

  column id, Int64, primary: true
#{field_definitions.empty? ? "" : "\n  #{field_definitions}"}

  setup_validations
  setup_callbacks
end
MODEL
        end

        private def generate_migration_content : String
          column_definitions = @fields.map do |field|
            name, type, options = parse_field_definition(field)
            sql_type = map_type_to_sql(type)
            null_constraint = options && options.includes?("nullable") ? "" : " NOT NULL"
            "    #{name} #{sql_type}#{null_constraint}"
          end

          columns_sql = if column_definitions.empty?
                          ""
                        else
                          ",\n" + column_definitions.join(",\n")
                        end

          <<-SQL
-- Migration: Create #{@table_name}
-- Generated: #{Time.utc}

-- +migrate Up
CREATE TABLE #{@table_name} (
    id BIGSERIAL PRIMARY KEY#{columns_sql},
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- +migrate Down
DROP TABLE IF EXISTS #{@table_name};
SQL
        end

        private def parse_field(field : String) : String
          name, type, options = parse_field_definition(field)

          crystal_type = map_type_to_crystal(type)

          if options && options.includes?("nullable")
            "column #{name}, #{crystal_type}?"
          else
            "column #{name}, #{crystal_type}"
          end
        end

        private def parse_field_definition(field : String) : Tuple(String, String, String?)
          parts = field.split(":")
          if parts.size < 2
            raise "Invalid field definition: #{field}. Expected format: name:type"
          end

          name = parts[0]
          type = parts[1]
          options = parts[2]?

          {name, type, options}
        end

        private def map_type_to_crystal(type : String) : String
          case type.downcase
          when "string", "text"
            "String"
          when "integer"
            "Int32"
          when "bigint"
            "Int64"
          when "float", "double"
            "Float64"
          when "boolean", "bool"
            "Bool"
          when "time", "datetime", "timestamp"
            "Time"
          when "json", "jsonb"
            "JSON::Any"
          when "uuid"
            "String"
          else
            "String" # Default fallback
          end
        end

        private def map_type_to_sql(type : String) : String
          case type.downcase
          when "string"
            "VARCHAR(255)"
          when "text"
            "TEXT"
          when "integer"
            "INTEGER"
          when "bigint"
            "BIGINT"
          when "float", "double"
            "DOUBLE PRECISION"
          when "boolean", "bool"
            "BOOLEAN"
          when "date"
            "DATE"
          when "time", "datetime", "timestamp"
            "TIMESTAMP"
          when "json"
            "JSON"
          when "jsonb"
            "JSONB"
          when "uuid"
            "UUID"
          when "binary", "blob"
            "BYTEA"
          else
            "TEXT" # Default fallback
          end
        end

        private def pluralize(str : String) : String
          str.pluralize
        end
      end
    end
  end
end
