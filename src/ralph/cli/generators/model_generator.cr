require "file_utils"

module Ralph
  module Cli
    module Generators
      class ModelGenerator
        @name : String
        @fields : Array(String)
        @table_name : String
        @class_name : String

        def initialize(name : String, fields : Array(String))
          @name = name
          @fields = fields
          @class_name = name.camelcase
          @table_name = name.underscore + "s"
        end

        def run
          create_model_file
          create_migration_file
          puts "Created model: #{@class_name}"
          puts "  - src/models/#{@name.underscore}.cr"
          puts "  - db/migrations/XXXX_create_#{@table_name}.cr"
        end

        private def create_model_file
          model_dir = "./src/models"
          FileUtils.mkdir_p(model_dir)

          model_file = File.join(model_dir, "#{@name.underscore}.cr")

          if File.exists?(model_file)
            puts "Model file already exists: #{model_file}"
            return
          end

          content = generate_model_content

          File.write(model_file, content)
        end

        private def create_migration_file
          migrations_dir = "./db/migrations"
          FileUtils.mkdir_p(migrations_dir)

          timestamp = Time.utc.to_s("%Y%m%d%H%M%S")
          migration_file = File.join(migrations_dir, "#{timestamp}_create_#{@table_name}.cr")

          content = generate_migration_content

          File.write(migration_file, content)
        end

        private def generate_model_content : String
          field_definitions = @fields.map do |field|
            parse_field(field)
          end.join("\n  ")

          <<-MODEL
# #{@class_name} model
#
# Generated by Ralph ORM

class #{@class_name} < Ralph::Model
  table "#{@table_name}"

  column id, Int64, primary: true
#{field_definitions.empty? ? "" : "\n  #{field_definitions}"}

  setup_validations
  setup_callbacks
end
MODEL
        end

        private def generate_migration_content : String
          column_definitions = @fields.map do |field|
            name, type, options = parse_field_definition(field)
            "t.column :#{name}, :#{type}"
          end.join("\n        ")

          table_plural = pluralize(@table_name)
          class_plural = pluralize(@class_name)

          <<-MIGRATION
# Migration: Create #{table_plural}
#
# Generated by Ralph ORM

class Create#{class_plural} < Ralph::Migration
  def up
    create_table("#{@table_name}") do |t|
      t.primary_key "id"
#{column_definitions.empty? ? "" : column_definitions + "\n        "}
      t.timestamps
    end
  end

  def down
    drop_table("#{@table_name}")
  end
end
MIGRATION
        end

        private def parse_field(field : String) : String
          name, type, options = parse_field_definition(field)

          crystal_type = map_type_to_crystal(type)

          if options && options.includes?("nullable")
            "column #{name}, #{crystal_type}?"
          else
            "column #{name}, #{crystal_type}"
          end
        end

        private def parse_field_definition(field : String) : Tuple(String, String, String?)
          parts = field.split(":")
          if parts.size < 2
            raise "Invalid field definition: #{field}. Expected format: name:type"
          end

          name = parts[0]
          type = parts[1]
          options = parts[2]?

          {name, type, options}
        end

        private def map_type_to_crystal(type : String) : String
          case type.downcase
          when "string", "text"
            "String"
          when "integer"
            "Int32"
          when "bigint"
            "Int64"
          when "float", "double"
            "Float64"
          when "boolean", "bool"
            "Bool"
          when "time", "datetime"
            "Time"
          when "json"
            "JSON::Any"
          else
            "String" # Default fallback
          end
        end

        private def pluralize(str : String) : String
          str.ends_with?("s") ? str : str + "s"
        end
      end
    end
  end
end

