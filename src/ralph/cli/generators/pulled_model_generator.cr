# Model Generator for db:pull
#
# Generates Ralph model files from database schema introspection.
# Takes a DatabaseTable and inferred associations to produce a Crystal model class.

require "file_utils"

module Ralph
  module Cli
    module Generators
      # Generates a Ralph model from a database table schema
      class PulledModelGenerator
        @table : Schema::DatabaseTable
        @associations : Array(InferredAssociation)
        @output_dir : String
        @class_name : String
        @file_name : String
        @dialect : Symbol

        def initialize(
          @table : Schema::DatabaseTable,
          @associations : Array(InferredAssociation),
          @output_dir : String,
          @dialect : Symbol = :sqlite,
        )
          @class_name = classify(@table.name)
          @file_name = "#{@table.name.singularize.underscore}.cr"
        end

        # Generate and return the result
        def generate : NamedTuple(path: String, content: String, class_name: String)
          content = build_model_content
          path = File.join(@output_dir, @file_name)

          {path: path, content: content, class_name: @class_name}
        end

        # Generate and write the file
        def generate! : String
          result = generate
          FileUtils.mkdir_p(@output_dir)
          File.write(result[:path], result[:content])
          result[:path]
        end

        private def build_model_content : String
          String.build do |io|
            # File header
            io << "# #{@class_name} model\n"
            io << "#\n"
            io << "# Generated by Ralph ORM from database schema\n"
            io << "# Table: #{@table.name}\n"
            io << "#\n"
            io << "# Review and customize this generated code as needed.\n"
            io << "\n"

            # Class definition
            io << "class #{@class_name} < Ralph::Model\n"
            io << "  table :#{@table.name}\n"
            io << "\n"

            # Include statements
            includes = detect_includes
            unless includes.empty?
              includes.each { |inc| io << "  #{inc}\n" }
              io << "\n"
            end

            # Column definitions
            io << "  # Columns\n"
            @table.columns.each do |col|
              # Skip columns handled by includes (timestamps, soft deletes)
              next if skip_column?(col, includes)
              io << "  #{column_definition(col)}\n"
            end
            io << "\n"

            # Association definitions
            belongs_to = @associations.select { |a| a.type == :belongs_to }
            has_many = @associations.select { |a| a.type == :has_many }
            has_one = @associations.select { |a| a.type == :has_one }

            unless belongs_to.empty?
              io << "  # Belongs To Associations\n"
              belongs_to.each { |a| io << "  #{a.to_macro_call}\n" }
              io << "\n"
            end

            unless has_many.empty?
              io << "  # Has Many Associations\n"
              has_many.each { |a| io << "  #{a.to_macro_call}\n" }
              io << "\n"
            end

            unless has_one.empty?
              io << "  # Has One Associations\n"
              has_one.each { |a| io << "  #{a.to_macro_call}\n" }
              io << "\n"
            end

            # Inferred validations
            validations = infer_validations(includes)
            unless validations.empty?
              io << "  # Validations\n"
              validations.each { |v| io << "  #{v}\n" }
              io << "\n"
            end

            io << "end\n"
          end
        end

        private def column_definition(col : Schema::DatabaseColumn) : String
          crystal_type = db_type_to_crystal(col.type, col.nullable)
          parts = ["column #{col.name} : #{crystal_type}"]

          if col.primary_key
            parts << ", primary: true"
          end

          # Add default if it's a simple value (not a function)
          if default = col.default
            unless is_function_default?(default)
              formatted_default = format_default(default, col.type)
              if formatted_default
                parts << ", default: #{formatted_default}"
              end
            end
          end

          parts.join
        end

        private def db_type_to_crystal(db_type : String, nullable : Bool) : String
          base_type = case db_type.downcase
                      # Integer types
                      when /^(integer|int|int4|smallint|int2|mediumint|tinyint)$/
                        "Int32"
                      when /^(bigint|int8|bigserial|serial8)$/
                        "Int64"
                      when /^(serial|serial4)$/
                        "Int32"
                        # String types
                      when /^(varchar|character varying|char|character|text|clob)/
                        "String"
                      when /^(uuid)$/
                        @dialect == :postgres ? "UUID" : "String"
                        # Numeric types
                      when /^(real|float4)$/
                        "Float32"
                      when /^(double|double precision|float8|float|decimal|numeric)/
                        "Float64"
                        # Boolean
                      when /^(boolean|bool)$/
                        "Bool"
                        # Binary
                      when /^(blob|bytea|binary)/
                        "Bytes"
                        # Date/Time
                      when /^(timestamp|datetime|date|time)/
                        "Time"
                        # JSON
                      when /^(json|jsonb)$/
                        "JSON::Any"
                        # Arrays (PostgreSQL)
                      when /^(.+)\[\]$/
                        element_type = db_type_to_crystal($1, false)
                        "Array(#{element_type})"
                      when /^_(.+)$/ # PostgreSQL internal array notation
                        element_type = db_type_to_crystal($1, false)
                        "Array(#{element_type})"
                      else
                        "String" # Default fallback
                      end

          nullable ? "#{base_type}?" : base_type
        end

        private def is_function_default?(default : String) : Bool
          # Database function defaults (not literal values)
          default.includes?("(") ||
            default.downcase.includes?("nextval") ||
            default.downcase.includes?("current_") ||
            default.downcase.includes?("now") ||
            default.downcase.includes?("identity") ||
            default.downcase.includes?("uuid")
        end

        private def format_default(default : String, db_type : String) : String?
          case default.downcase
          when "null"
            "nil"
          when "true", "'t'", "1"
            return nil unless db_type.downcase.includes?("bool")
            "true"
          when "false", "'f'", "0"
            return nil unless db_type.downcase.includes?("bool")
            "false"
          when /^'(.*)'$/
            "\"#{$1}\""
          when /^(-?\d+)$/
            $1
          when /^(-?\d+\.\d+)$/
            $1
          else
            nil # Complex default, skip
          end
        end

        private def detect_includes : Array(String)
          includes = [] of String

          # Detect timestamps (created_at and updated_at)
          has_created_at = @table.has_column?("created_at")
          has_updated_at = @table.has_column?("updated_at")
          if has_created_at && has_updated_at
            includes << "include Ralph::Timestamps"
          end

          # Detect soft deletes (deleted_at)
          if @table.has_column?("deleted_at")
            includes << "include Ralph::ActsAsParanoid"
          end

          includes
        end

        private def skip_column?(col : Schema::DatabaseColumn, includes : Array(String)) : Bool
          # Skip columns that are handled by includes
          if includes.includes?("include Ralph::Timestamps")
            return true if col.name == "created_at" || col.name == "updated_at"
          end

          if includes.includes?("include Ralph::ActsAsParanoid")
            return true if col.name == "deleted_at"
          end

          false
        end

        private def infer_validations(includes : Array(String)) : Array(String)
          validations = [] of String

          # Columns to skip for presence validation
          skip_presence = Set{"id", "created_at", "updated_at", "deleted_at"}

          # Find NOT NULL columns that should have presence validation
          @table.columns.each do |col|
            next if col.primary_key
            next if col.nullable
            next if skip_presence.includes?(col.name)
            next if col.default                # Has a default, so presence not strictly required
            next if col.name.ends_with?("_id") # FK columns - handled by association

            validations << "validates_presence_of :#{col.name}"
          end

          # Find unique indexes for uniqueness validation
          @table.indexes.each do |idx|
            next unless idx.unique
            next if idx.columns.size != 1 # Only single-column unique indexes
            col_name = idx.columns.first
            next if col_name == "id"             # Skip PK
            next if idx.name.ends_with?("_pkey") # Skip primary key indexes

            validations << "validates_uniqueness_of :#{col_name}"
          end

          validations.uniq
        end

        # Convert table name to class name
        private def classify(name : String) : String
          name.singularize.split('_').map(&.capitalize).join
        end
      end
    end
  end
end
