# Migration Generator for db:generate
#
# Generates migration files from schema diffs produced
# by the SchemaComparator.

require "file_utils"

module Ralph
  module Schema
    class MigrationGenerator
      @diff : SchemaDiff
      @name : String
      @output_dir : String
      @dialect : Symbol

      def initialize(@diff, @name = "auto_migration", @output_dir = "./db/migrations", @dialect = :sqlite)
      end

      def generate : NamedTuple(path: String, content: String)
        timestamp = Time.utc.to_s("%Y%m%d%H%M%S")
        class_name = @name.split("_").map(&.capitalize).join
        file_name = "#{timestamp}_#{@name.underscore}.cr"
        path = File.join(@output_dir, file_name)

        content = build_migration_content(class_name)

        {path: path, content: content}
      end

      def generate! : String
        result = generate
        FileUtils.mkdir_p(@output_dir)
        File.write(result[:path], result[:content])
        result[:path]
      end

      private def build_migration_content(class_name : String) : String
        String.build do |io|
          # Header comment
          io << "# Migration: #{class_name}\n"
          io << "#\n"
          io << "# Generated by Ralph db:generate\n"
          if @diff.has_destructive_changes?
            io << "#\n"
            io << "# ⚠️  WARNING: This migration contains destructive changes!\n"
            io << "# Review carefully before running.\n"
          end
          io << "\n"

          # Class definition
          io << "class #{class_name} < Ralph::Migration\n"
          io << "  def up\n"

          # Generate up method
          generate_up_method(io)

          io << "  end\n"
          io << "\n"
          io << "  def down\n"

          # Generate down method
          generate_down_method(io)

          io << "  end\n"
          io << "end\n"
        end
      end

      private def generate_up_method(io : IO)
        @diff.changes.each do |change|
          if warning = change.warning
            io << "    # ⚠️  #{warning}\n"
          end

          case change.type
          when .create_table?
            generate_create_table(io, change)
          when .drop_table?
            io << "    drop_table(\"#{change.table}\")\n"
          when .add_column?
            io << "    add_column(\"#{change.table}\", \"#{change.column}\", :#{change.details["type"]}"
            if change.details["nullable"]? == "true"
              io << ", null: true"
            end
            io << ")\n"
          when .remove_column?
            io << "    remove_column(\"#{change.table}\", \"#{change.column}\")\n"
          when .change_column_type?
            if @dialect == :sqlite
              io << "    # SQLite does not support ALTER COLUMN TYPE\n"
              io << "    # Manual migration required for: #{change.table}.#{change.column}\n"
            else
              io << "    change_column(\"#{change.table}\", \"#{change.column}\", :#{change.details["to"]})\n"
            end
          when .change_column_nullable?
            if change.details["to"]? == "false"
              io << "    change_column_null(\"#{change.table}\", \"#{change.column}\", false)\n"
            else
              io << "    change_column_null(\"#{change.table}\", \"#{change.column}\", true)\n"
            end
          when .add_foreign_key?
            io << "    add_foreign_key(\"#{change.table}\", \"#{change.details["to_table"]}\", column: \"#{change.column}\")\n"
          when .remove_foreign_key?
            io << "    remove_foreign_key(\"#{change.table}\", column: \"#{change.column}\")\n"
          when .add_index?
            io << "    add_index(\"#{change.table}\", \"#{change.column}\")\n"
          when .remove_index?
            io << "    remove_index(\"#{change.table}\", \"#{change.column}\")\n"
          end
        end

        if @diff.empty?
          io << "    # No changes detected\n"
        end
      end

      private def generate_down_method(io : IO)
        # Reverse operations
        @diff.changes.reverse_each do |change|
          case change.type
          when .create_table?
            io << "    drop_table(\"#{change.table}\")\n"
          when .drop_table?
            io << "    # Cannot automatically reverse drop_table\n"
            io << "    # Manual recreation required for: #{change.table}\n"
          when .add_column?
            io << "    remove_column(\"#{change.table}\", \"#{change.column}\")\n"
          when .remove_column?
            io << "    # Cannot automatically reverse remove_column\n"
            io << "    # add_column(\"#{change.table}\", \"#{change.column}\", :TYPE)\n"
          when .change_column_type?
            io << "    change_column(\"#{change.table}\", \"#{change.column}\", :#{change.details["from"]})\n"
          when .change_column_nullable?
            # Reverse the nullable change
            io << "    change_column_null(\"#{change.table}\", \"#{change.column}\", #{change.details["from"]})\n"
          when .add_foreign_key?
            io << "    remove_foreign_key(\"#{change.table}\", column: \"#{change.column}\")\n"
          when .remove_foreign_key?
            io << "    # Cannot automatically reverse remove_foreign_key\n"
          when .add_index?
            io << "    remove_index(\"#{change.table}\", \"#{change.column}\")\n"
          when .remove_index?
            io << "    # Cannot automatically reverse remove_index\n"
          end
        end

        if @diff.empty?
          io << "    # No changes to reverse\n"
        end
      end

      private def generate_create_table(io : IO, change : SchemaChange)
        io << "    create_table(\"#{change.table}\") do |t|\n"
        # The columns info is just a comma-separated list of names in details
        # In a real implementation, we'd have full column info
        io << "      # TODO: Define columns\n"
        io << "      # Columns needed: #{change.details["columns"]}\n"
        io << "    end\n"
      end
    end
  end
end
